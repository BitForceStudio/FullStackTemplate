# Security

In this section, our goal is to build a vue + spring security framework which support

* https
* login / logout
* develop locally

Firstly, let's

* copy the code from basics, including `\backend` and `\frontend`

## Add Security to Project

Let's firstly add a very simple spring security demo by using in memory user. 

Like always, set things up by 3 steps

* Dependency
    * `implementation 'org.springframework.boot:spring-boot-starter-security'`
* Yaml configuration
    * null
* Implementation
    * Simple test:
    * create `UserManagerSecurityConfiguration.java` in `\configuration` directory

`UserManagerSecurityConfiguration.java`
```java
@EnableWebSecurity
public class UserManagerSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().antMatchers("/user/**").hasRole("ADMIN");
        http.formLogin();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication().withUser("admin").password(passwordEncoder().encode("admin")).roles("ADMIN");
    }
}
```

Open browser and goto `http://localhost:8002/user/get/abc/abc`, then it redirected to the login page autogenerated by Spring Security. Input username (admin) and password (admin) to check the implementation. 

## SSL and HTTPS

### Definition

* SSL
    * SSL stands for Secure Sockets Layer and, in short, it's the standard technology for keeping an internet connection secure and safeguarding any sensitive data that is being sent between two systems, preventing criminals from reading and modifying any information transferred, including potential personal details. The two systems can be a server and a client (for example, a shopping website and browser) or server to server (for example, an application with personal identifiable information or with payroll information).
* HTTPS
    * HTTPS (Hyper Text Transfer Protocol Secure) appears in the URL when a website is secured by an SSL certificate. The details of the certificate, including the issuing authority and the corporate name of the website owner, can be viewed by clicking on the lock symbol on the browser bar.

### Get Certificate Ready

There are two ways to get certificate
* Self Signed
* Buy from trust organizations

Here we are going to use Self Signed certificate. We can generate it by keytool provided by JDK

```bash
.\keytool.exe -genkeypair -alias certificate_name -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore certificate_name.p12 -validity 3650 -keypass password -storepass certificate_password
```

* `genkey`: generates a key
* `alias`: the alias name for the item we are generating;
* `keyalg`: the cryptographic algorithm to generate the key pair;
* `keysize`: the size of the key. We have used 2048 bits, but 4096 would be a better choice for production;
* `storetype`: the type of keystore;
* `keystore`: the name of the keystore;
* `validity`: validity number of days;

After generating the certificate file, copy this file to the project directory `resources/secret/certificate_name.p12`. 

### Add Config to `application.yml`

In order to enable SSL, we should add some configuration to `application.yml`

```yaml
server:
  ssl:
    enabled: true
    key-store: src/main/resources/statics/secret/certificate_name.p12
    key-store-password: certificate_password
    keyStoreType: PKCS12
    keyAlias: certificate_name
```

### Add Config to Spring Boot

Here, we has to 

* enable SSL trafic
* add HTTP to HTTPS redirecting. 

In order to keep code base clean, we create another config class to handle SSL separately, `configuration/ServerConfig.java`, and add the following code. 

ServerConfig.java
```java
@Configuration
public class ServerConfig {

    @Bean
    public ServletWebServerFactory servletContainer() {
        // Enable SSL Trafic
        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() {
            @Override
            protected void postProcessContext(Context context) {
                SecurityConstraint securityConstraint = new SecurityConstraint();
                securityConstraint.setUserConstraint("CONFIDENTIAL");
                SecurityCollection collection = new SecurityCollection();
                collection.addPattern("/user/*");
                securityConstraint.addCollection(collection);
                context.addConstraint(securityConstraint);
            }
        };

        // Add HTTP to HTTPS redirect
        tomcat.addAdditionalTomcatConnectors(httpToHttpsRedirectConnector());

        return tomcat;
    }

    /*
    We need to redirect from HTTP to HTTPS. Without SSL, this application used
    port 8002. With SSL it will use port 8443. So, any request for 8002 needs to be
    redirected to HTTPS on 8443.
     */
    private Connector httpToHttpsRedirectConnector() {
        Connector connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);
        connector.setScheme("http");
        connector.setPort(8002);
        connector.setSecure(false);
        connector.setRedirectPort(8443);
        return connector;
    }
}
```

To test the SSL, we could firstly try "https://localhost:8443/login", it should show the Spring security build in login page. And then we should try http redirecting by "http://localhost:8002/login", the request should be redirect to `https`

## User Services

Spring security intergreted several useful user services to handle user related actions, such as login, logout, cookie (remember me) and so on. 

In this demo, we are going to do the following to intergrate database backed user services and intergrate user service with authn & authz,  

* implement `UserDetails` interface as `UserDetailsImp`
* implement `UserDetailsService` interface as `UserDetailsServiceImpl`
* create auth provider with `UserDetailsService` instance (bean) based on Dao in configuration

### Implement `UserDetails`

There are lots of methods need to override. We can default the return value as `true` for those boolean type method, and focus on the `getAuthorities()`. We need to add permissions and roles to the authorities list. 

`service\impl\UserDetailsImpl.java`
```java
public class UserDetailsImpl implements UserDetails {
    ...

    private User user;

    public UserDetailsImpl(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<GrantedAuthority> authorities = new ArrayList<>();

        System.out.println(user);

        // get list of permissions
        user.getPermissionsList().forEach(p -> {
            authorities.add(new SimpleGrantedAuthority(p));
        });

        // get list of roles
        user.getRolesList().forEach(r -> {
            authorities.add(new SimpleGrantedAuthority(r));
        });
        return authorities;
    }

    ...
}
```

### Implement 'UserDetailsService'

Spring security helps us to check the user name and password, we only need to implement an interface to return a UserDetails instance, this interface is `UserDetailsService`. 

We also need to register this class as a Spring service. 

`service\impl\UserDetailsServiceImpl.java`
```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private UserDao userDao;

    public UserDetailsServiceImpl(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userDao.getUserByUserName(username);
        UserDetails userDetails = new UserDetailsImpl(user);
        return userDetails;
    }
    
}
```

### Intergrate `UserDetailsService` with Auth Provider

This is the final step to enable database backed user services auth. 

* autowire `UserDetailsService`
* Add a `DaoAuthenticationProvider` auth provider as a bean
* Replace `inMemoryAuthentication` by auth provider
* Update authorize request roles. 
    * give `\login` and `\signup` public permission
    * limit `\user\**` permission to logined user. 

`configuration\UserManagerSecurityConfiguration.java`
```java
@Configuration
@EnableWebSecurity
@Slf4j
public class UserManagerSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .antMatchers("/login**").permitAll()
            .antMatchers("/signup**").permitAll()
            .antMatchers("/user/**").authenticated()
            .and()
            .csrf().disable()
            .cors();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authenticationProvider());
    }

    @Bean
    DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider();
        authenticationProvider.setPasswordEncoder(passwordEncoder());
        authenticationProvider.setUserDetailsService(userDetailsService);

        return authenticationProvider;
    }

    ...
}
```

We can simply add a user in database and test the login by "https://localhost:8443/login". 

### One More Thing on CORS

Cors is a pure pain when developing locally. Here we used the cookie to carry auth, so that we need to enable the "Access-Control-Allow-Credentials" in sever side. 

While we are also going to use the Vue as front end framework, so we need to add a proper filter for Cors to the Spring, like the following,

```java
@Component
@Order(1)
public class MyCorsFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest)request;
        HttpServletResponse resp = (HttpServletResponse)response;
        
        String origin = req.getHeader("Origin");
        if(origin == null) {
            origin = req.getHeader("Referer");
        }
        resp.setHeader("Access-Control-Allow-Origin", origin);
        resp.setHeader("Access-Control-Allow-Credentials", "true");
        
        if(RequestMethod.OPTIONS.toString().equals(req.getMethod())) {
            String allowMethod = req.getHeader("Access-Control-Request-Method");
            String allowHeaders = req.getHeader("Access-Control-Request-Headers");
            resp.setHeader("Access-Control-Max-Age", "86400");
            resp.setHeader("Access-Control-Allow-Methods", allowMethod);
            resp.setHeader("Access-Control-Allow-Headers", allowHeaders);
            return;
        }

        chain.doFilter(request, response);
    }
}
```

### Add Sign Up Method

Add the following code to handle the signup post 

`controller\UserManagerController.java`
```java
    @PostMapping(value = "/signup")
    public String signup(@RequestBody UserBasic userBasic) {
        log.info(userBasic.getUsername());
        return userManagerService.signup(userBasic.getUsername(), 
                                         passwordEncoder.encode(userBasic.getPassword()));
    }
```

where the UserBasic only has two members, like following

`entities\UserBasic.java`
```java
@AllArgsConstructor
@Getter
public class UserBasic {
    private String username;
    private String password;
}
```

### Add GetUserInfo

In UserManagerController, add the following code to handle the GetUserInfo method, which will return the user detail. Remeber, after we implement the auth, every request start with `/user/` has to be authenticated. 

`controller\UserManagerController.java`
```java
    @GetMapping(value = "/user/getUserInfo/{username}")
    public Object getUserInfo(@PathVariable("username") String username) {
        log.info("get user info " + username);
        User user = userManagerService.getUserbyUserName(username);
        
        UserInfo userInfo = new UserInfo(user.getUserName(), user.getModifiedTime().toString(), user.getRoles().toString());
        return userInfo;
    }
```

We also defined a Class called UserInfo which contains user information which can be safely send to the client. 

`entities\UserInfo.java`
```java
@Getter
@Setter
@AllArgsConstructor
public class UserInfo {
    private String username;
    private String modifiedTime;
    private String role;
}
```

### Make Everything RESTful

By now we uses Spring buildin login method, however what we want is the pure RESTful APIs. Now let's change the configuration to disable http based login and enable logout. Meanwhile, we will add the login sucess/failed and logout handler. 

1. Disable http based login page and enable logout in configuration

`configuration\UserManagerSecurityConfiguration.java`
```java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .antMatchers("/login**").permitAll()
            .antMatchers("/signup**").permitAll()
            .antMatchers("/user/**").authenticated()
            .formLogin().loginPage("/login")
                        .successHandler(new AuthSuccessHandler())
                        .failureHandler(new AuthFailHandler())
                        .loginProcessingUrl("/login")
                        .and()
                        .logout().logoutSuccessHandler(new LogoutSuccessHandler())
                        .logoutUrl("/logout")
            .and()
            .httpBasic().disable()
            .csrf().disable()
            .cors();
    }
```

2. Handlers methods

`configuration\UserManagerSecurityConfiguration.java`
```java
    // success handler
    private class AuthSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {
        @Override
        public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
            
            log.info("user [" + SecurityContextHolder.getContext().getAuthentication().getPrincipal() +"] login successful");
            // remove session code after login successfully
            request.getSession().removeAttribute("codeValue");
            request.getSession().removeAttribute("codeTime");
            
            PrintWriter out = response.getWriter();
            out.write("{\"status\":\"ok\",\"msg\":\"login success\"}");
            out.flush();
            out.close();
        }
    }

    // failed handler
    private class AuthFailHandler extends SimpleUrlAuthenticationFailureHandler {
        @Override
        public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
            //remove session code after login failed
            request.getSession().removeAttribute("codeValue");
            request.getSession().removeAttribute("codeTime");

            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            PrintWriter out = response.getWriter();
            out.write("{\"status\":\"error\",\"msg\":\"login failed\"}");
            out.flush();
            out.close();
        }
    }

    // customize exceptions
    public class UnauthorizedEntryPoint implements AuthenticationEntryPoint {
        @Override
        public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
            response.sendError(HttpStatus.UNAUTHORIZED.value(),authException.getMessage());
        }

    }
    
    // define log out message
    private class LogoutSuccessHandler extends SimpleUrlLogoutSuccessHandler  {

        public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response,
                Authentication authentication) throws IOException, ServletException {
            PrintWriter out = response.getWriter();
            out.write("{\"status\":\"ok\",\"msg\":\"logout success\"}");
            out.flush();
            out.close();
        }
    }
```

### Test Backend APIs

So far, we've already implement four RESTful api with Spring security. 

* POST: https://localhost:8443/login
    * Query Params:
        * username: string
        * password: string
* POST: https://localhost:8443/signup
    * Data:
        * username: string
        * password: string
* GET:  https://localhost:8443/user/getUserInfo/<userinfo>
* GET:  https://localhost:8443/logout

We can test these with Postman.

1. Test `signup` api

    1. Select POST and input the URL: https://localhost:8443/signup 
    2. Select Headers tab and input `Content-Type | application/json;charset=UTF-8` which override the default setings. 
    3. Select Body tab and input following JSON object

```json
{
    "username": "a",
    "password": "a"
}
```

The return value should be 1, which indicate signup successfully. 

2. Test `getuserinfo` api

    1. Select GET and input the URL: https://localhost:8443/user/getUserInfo/a , here we want to get user info of "a"
    2. Because we haven't logged in, so the reponse ask us to login first

```json
{
    "timestamp": "2020-07-05T14:58:07.772+00:00",
    "status": 404,
    "error": "Not Found",
    "message": "",
    "path": "/login"
}
``` 

3. Test `login` api

    1. Select POST and input the URL: https://localhost:8443/login
    2. Add the Query Params: `username | a` and `password | a`
    3. The response will show success, and a cookie should be included as well. In response Headers tab, it should show a row like

```
Set-Cookie: JSESSIONID=XXXXXXXXXXxxxxxXXXXXXXX; Path=/; Secure; HttpOnly
```
Here `Path=/` means this cookie can be used from root. `HttpOnly` means this cookies is not accessable from script, like javascript. Now let's copy this cookie somewhere, we may need it in the next test.  

After we logged in, we obtained a cookie, which actually is a session id. This session id is a unique id autogenerated by the backend service (Spring security) and this session id will be used to handel the user auth, expiration time and etc. Now we should be able to get user info. 

4. Test `getuserinfo` api again

    1. Select GET and input the URL: https://localhost:8443/user/getUserInfo/a , here we want to get user info of "a"
    2. Select request Headers tab and double check the cookies value, if it doesn't match the Cookie we obtained, replace the cookie with what we just obtained. 
    3. The response should show the user info with username, modified time and role, like following 

```json
{
    "username": "a",
    "modifiedTime": "Sun Jul 05 15:49:54 BST 2020",
    "role": "USER"
}
```

5. Test `logout` api

    1. Select GET and input the URL: https://localhost:8443/logout 
    2. The response will show the logout successfully message. 
    3. To test logout, using `getuserinfo` api again, it will fail on retrive user info and try to direct to login page. 

## Front End

I am a noob to the FE. Here I am focusing on the basic funcationalities and configs. 

Let's finish the configuration for HTTPS and CORS first. 

### Configuraiton

There are two steps, first step is to add the vue configuraiton file `vue.config.js` to the root directory, the content is

`vue.config.js`
```javascript
module.exports = {
  configureWebpack: {
    devServer: {
      proxy: {
        "/api": {
          target: "https://localhost:8443",
          changeOrigin: true,
          ws: true,
          pathRewrite: {
            "^/api": ""
          }
        }
      },
      https: true,
      headers: {
        "Access-Control-Allow-Origin": "http://localhost:3000",
        "Access-Control-Allow-Credentials": "true",
        "Access-Control-Allow-Methods":
          "GET, POST, PUT, DELETE, PATCH, OPTIONS",
        "Access-Control-Allow-Headers":
          "X-Requested-With, content-type, Authorization"
      }
    }
  }
};
```
Because we are going to use CORS auth, so we have to change `axios` default config in `main.ts` (I use typescript)

`main.ts`
```typescript
import Vue from "vue";
import App from "./App.vue";
import router from "./router";
import store from "./store";
import axios from "axios";
import VueCookies from "vue-cookies";

Vue.use(VueCookies);
Vue.config.productionTip = false;
// change axios default to include credencials (cookies in this case)
axios.defaults.withCredentials = true;
Vue.prototype.$axios = axios;

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount("#app");

```

### API Impl

Here we need 4 APIs, which are

* signup
* login
* getuserinfo
* logout

Here I just show how to login and the others are the same. Correct me if I am wrong, I found the steps to implement new API are 

1. Create a XxxxComponent.vue in component directory
    1. this compounent should contain most functionalities of this specific component
2. Create a XxxxView.vue in view directory
    1. this view should only handle the router input and the shared component, like header, footer and sider. 
3. Add path in router, expose the link in header if necessary. 
4. Add object interface if necessary

Here is the code

* Component

`components\user\Login.vue`
```html
<template>
  <div id="user-login-form">
    <h3 class="title">Login Form</h3>
    <input
      ref="username"
      v-model="loginForm.username"
      placeholder="Username"
      name="username"
      type="text"
    />
    <input
      ref="password"
      v-model="loginForm.password"
      placeholder="Password"
      name="password"
    />

    <button v-on:click="handleLogin()">Login</button>
  </div>
</template>

<script lang="ts">
import { Prop, Vue, Component } from "vue-property-decorator";
import axios from "axios";
import { LoginForm } from "@/utils/user/interfaces";
import { Utils } from "@/utils/utils";

@Component
export default class Login extends Vue {
  @Prop()
  private loginForm!: LoginForm;

  public async handleLogin() {
    console.log(this.loginForm);
    const url = Utils.getLoginUrl(
      this.loginForm.username,
      this.loginForm.password
    );
    const res = await axios.post(url);
    console.log(res);
    if (res.status === 200) {
      this.$router.push({
        name: "UserHome",
        params: { username: this.loginForm.username }
      });
    } else {
      this.$router.push({ name: "UserLogin" });
    }
  }
}
</script>
```

* views

`views\user\UserLogin.vue`
```html
<template>
  <div class="login">
    <Login v-bind:loginForm="this.loginForm" />
  </div>
</template>

<script>
// @ is an alias to /src
import Login from "@/components/user/Login.vue";

export default {
  name: "UserLogin",
  data() {
    return {
      loginForm: {
        username: "",
        password: ""
      }
    };
  },
  components: {
    Login
  }
};
</script>
```

* router

`router\index.ts`
```typescript
import Vue from "vue";
import VueRouter, { RouteConfig } from "vue-router";
import Home from "../views/Home.vue";
import About from "../views/About.vue";
import UserLogin from "../views/user/UserLogin.vue";

Vue.use(VueRouter);

const routes: Array<RouteConfig> = [
  {
    path: "/",
    name: "Home",
    component: Home
  },
  {
    path: "/about",
    name: "About",
    component: About
  },
  {
    path: "/user/login",
    name: "UserLogin",
    component: UserLogin
  }
];

const router = new VueRouter({
  mode: "history",
  base: process.env.BASE_URL,
  routes
});

export default router;
```

* interfaces & utils

`utils\user\interfaces.ts`
```typescript
export interface LoginForm {
  username: string;
  password: string;
}

export interface SignupForm {
  username: string;
  password: string;
}

export interface UserInfo {
  username: string;
  modifiedTime: string;
  role: string;
}

```

`utils\utils.ts`
```typescript
export class Utils {
  private static URL_PREFIX = "/api/";

  public static getSignupUrl(): string {
    return Utils.URL_PREFIX + `signup`;
  }

  public static getLoginUrl(username: string, password: string): string {
    return (
      Utils.URL_PREFIX + `login?username=` + username + `&password=` + password
    );
  }

  public static getLogoutUrl(): string {
    return Utils.URL_PREFIX + `logout`;
  }

  public static getUrl(category: string, request: string): string {
    return (
      Utils.URL_PREFIX +
      (category.length === 0 ? "" : category + "/") +
      (request.length === 0 ? "" : request + "/")
    );
  }
}
```